一、基础结构
1.Spring MVC+Spring+Hibernate结构介绍如下：

Spring MVC
Spring MVC的职责是作为web层框架，实现了我们常见的MVC模式
Spring
Spring 作为服务层，利用自身特性IOC、AOP，提供数据从DAO层到Web层的桥梁作用。
Hibernate
Hibernate作为熟知的ORM框架，提供了从数据库读取数据映射到实体的功能，这里我们将Hibernate服务于DAO层


2.项目结构
基于Spring MVC+Spring+Hibernate架构，面向接口编程，搭建项目,分为Model、DAO、Service、ViewModel、Web层，具体介绍如下

Model
分为数据库实体和逻辑model两块，提供DAO和Service的数据实体和业务逻辑model
DAO
基于Hibernate，提供数据库读取，提供基本的增删改查和数据访问功能，供Service调用
Service
业务逻辑层，通过调用DAO的提供的数据访问接口，整合业务逻辑，将数据提供给Web层,基于Spring的依赖注入和切面编程，提供面向接口的服务
ViewModel
页面展现model，提供给web层
Web
提供一个用户界面，调用Service提供的数据接口，实现用户交互操作



二.hibernate
1.在resources下配置数据库连接文件，gcrm.cfg.xml，具体内容如下:

<?xml version='1.0' encoding='utf-8'?>
<!DOCTYPE hibernate-configuration PUBLIC
        "-//Hibernate/Hibernate Configuration DTD//EN"
        "http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
<hibernate-configuration>
    <session-factory>
        <property name="connection.url">jdbc:mysql://ip地址:端口号/数据库名</property>
        <property name="connection.driver_class">com.mysql.jdbc.Driver</property>
        <property name="connection.username">username</property>
        <property name="connection.password">pwd</property>
        <property name="current_session_context_class">thread</property>
    </session-factory>
</hibernate-configuration>

2.添加entity与resource的映射
1）*.hbm.xml文件
多个实体类可以配置在一个XML文件中。Hibernate推荐XML映射文件和实体类同名，便于阅读和维护，比如UsersVo.java文件对应UsersVo. hbm.xml文件。XML文件一般以“.hbm.xml”结尾，便于辨认，也可以直接用“.xml”结尾。例如UsersVo类的映射文件可取名为“UsersVo.hbm.xml”或者“UsersVo.xml”。使用XML文件配置实体类映射的时候，实体类和普通的实体类一样，和数据库的映射关系放在XML文件中，UsersVo. hbm.xml文件代码如下：
 <?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
"http://hibernate.sourceforge.net/hibernate-mapping-3.0.dtd">
<!-- 
    Mapping file autogenerated by MyEclipse Persistence Tools
-->
<hibernate-mapping>
<!--  name=””用来指定实体类， table="”用来指定数据库表格 catalog表示连接的数据库 lazy表示延迟加载 -->
    <class name="com.cn.vo.UsersVo" table="users" catalog="bank" lazy="false">
        <id name="id" type="java.lang.Integer"><!--  配置实体类变量-->
            <column name="id" /><!--  主键的字段名  -->
            <generator class="assigned" /><!-- 主键 类型，这里设置成不主动增长 -->
        </id>
        <property name="name" type="java.lang.String"><!--  配置实体类变量-->
            <column name="name" length="20" /><!--  数据库的字段名和字段长度  -->
        </property>
        <property name="age" type="java.lang.Integer"><!--  配置实体类变量  -->
            <column name="age" length="3" /><!--  数据库的字段名和字段长度  -->
        </property>
        <property name="tel" type="java.lang.String"><!--  配置实体类变量  -->
            <column name="tel" length="20" /><!--  数据库的字段名和字段长度  -->
        </property>
        <property name="address" type="java.lang.String"><!--  配置实体类变量  -->
            <column name="address" length="50" /><!--  数据库的字段名和字段长度  -->
        </property>
    </class>
</hibernate-mapping>
代码中的DOCTYPE指定的dtd文件位于hibernate.jar中。dtd文件为XML格式验证文件，Hibernate使用该dtd来验证该XML文件格式是否正确。如果hibernate.jar或者classpath中不存在该dtd文件，Hibernate会到指定的URL下载该文件。
在上述的映射文件中，<class>中的name表示实体类的路径和名称。table="”用来指定数据库表格 catalog表示连接的数据库 lazy表示延迟加载，<id>用来声明表的主键，<id>中的属性name="id"表示实体类的属性id。数据库对应的字段名放在<column>中，<column>中的name表示表中的字段名，<generator class="assigned" />表示数据库表的主键类型为默认的类型，默认的类型是不自动增长类型，在<property>中映射表中的其他字段，<property>中的name属性值表示实体类的属性，type表示实体类属性的类型。表字段的映射放在<column>中，name的值是字段名，length表示字段长度。


2）在hibernate.cfg.xml文件中配置实体类映射
实体类还需要配置到hibernate.cfg.xml中，以便Hibernate初始化实体类与数据库表的映射关系。如果只配置了映射关系，而没有配置到hibernate.cfg.xml中，Hibernate是无法解析实体类的，因为Hibernate无法自行判断哪些是实体类。
如果实体类是使用@注解配置的，需要用<mapping class=””/>配置，而如果是用XML文件配置的，需要用<mapping resource=””/>配置XML配置文件。hibernate.cfg.xml文件中配置实体类映射的示例代码如下：
<!-- 使用XML映射文件映射实体类的配置 -->
<mapping resource="com/cn/vo/UsersVo.hbm.xml"/>
<mapping resource="com/cn/vo/DeptVo.hbm.xml"/>
<!-- 使用@注解映射实体类的配置 -->
<mapping class="com.cn.vo.UsersVo "/>
<mapping class="com.cn.vo.DeptVo "/>

3）使用@注解配置实体类
实体类一般有ID、普通属性、集合属性等，分别对应数据库的主键、普通列、外键。@注解配置中，实体类用@Entity注解，用@Table指定对应的数据表，用@Id配置主键，用@Column配置普通属性，用@OneToMany、@ManyToOne、@OneToOne、@ManyToMany配置实体间关系等。





